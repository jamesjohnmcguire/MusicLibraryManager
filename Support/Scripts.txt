##########################
	Audio Conversion
		Download SoX from: http://sox.sourceforge.net/

		ffmpeg -i input.m4a output.wav

		# Convert with specific sample rate and bit depth
		ffmpeg -i input.m4a -acodec pcm_s16le -ar 44100 output.wav

		# Convert with higher quality settings
		ffmpeg -i input.m4a -acodec pcm_s24le -ar 96000 output.wav

		# Convert while preserving metadata
		ffmpeg -i input.m4a -acodec pcm_s16le -map_metadata 0 output.wav

		# To PCM Raw (headerless)
		ffmpeg -i input.m4a -f s16le -acodec pcm_s16le output.raw

		diff audio
			First, you can extract just the metadata to compare it separately:
				ffmpeg -i file1.m4a -f ffmetadata metadata1.txt
				ffmpeg -i file2.m4a -f ffmetadata metadata2.txt
			Convert both files to raw PCM with identical parameters:
				ffmpeg -i file1.m4a -f s16le -acodec pcm_s16le -ar 44100 -ac 2 file1.raw
				ffmpeg -i file2.m4a -f s16le -acodec pcm_s16le -ar 44100 -ac 2 file2.raw

			Important parameters explained:

			-f s16le: Format is 16-bit little-endian
			-acodec pcm_s16le: PCM signed 16-bit little-endian codec
			-ar 44100: Sample rate of 44100 Hz (CD quality)
			-ac 2: 2 channels (stereo)
			Compare the raw files. On Windows, you can use:
			bash
			# Using FC (File Compare) command
			fc /b file1.raw file2.raw

			You can also check the exact specifications of each M4A file:
			ffmpeg -i file1.m4a -hide_banner

			compare_audio.bat
				@echo off
				setlocal EnableDelayedExpansion

				REM Check if two arguments were provided
				if "%~2"=="" (
					echo Usage: %~nx0 file1.m4a file2.m4a
					echo Both files must be m4a format
					exit /b 1
				)

				REM Store the file names without extension for working files
				set "file1_base=%~n1"
				set "file2_base=%~n2"

				echo Comparing files:
				echo 1: %~1
				echo 2: %~2
				echo.

				REM Create a temporary working directory
				set "temp_dir=%TEMP%\audio_compare_%RANDOM%"
				mkdir "%temp_dir%"

				echo Extracting metadata...
				ffmpeg -i "%~1" -f ffmetadata "%temp_dir%\%file1_base%_metadata.txt" 2>nul
				ffmpeg -i "%~2" -f ffmetadata "%temp_dir%\%file2_base%_metadata.txt" 2>nul

				echo Comparing metadata...
				fc "%temp_dir%\%file1_base%_metadata.txt" "%temp_dir%\%file2_base%_metadata.txt" > "%temp_dir%\metadata_diff.txt"
				if errorlevel 1 (
					echo Metadata differences found - see "%temp_dir%\metadata_diff.txt"
				) else (
					echo No metadata differences found
				)
				echo.

				echo Converting to raw PCM format...
				ffmpeg -i "%~1" -f s16le -acodec pcm_s16le -ar 44100 -ac 2 "%temp_dir%\%file1_base%.raw" 2>nul
				ffmpeg -i "%~2" -f s16le -acodec pcm_s16le -ar 44100 -ac 2 "%temp_dir%\%file2_base%.raw" 2>nul

				echo Comparing raw audio data...
				fc /b "%temp_dir%\%file1_base%.raw" "%temp_dir%\%file2_base%.raw" > "%temp_dir%\audio_diff.txt"
				if errorlevel 1 (
					echo Audio content differences found - see "%temp_dir%\audio_diff.txt"
				) else (
					echo No audio content differences found
				)

				echo.
				echo Temporary files stored in: %temp_dir%
				echo.
				echo Files created:
				echo - Metadata files: %file1_base%_metadata.txt, %file2_base%_metadata.txt
				echo - Raw audio files: %file1_base%.raw, %file2_base%.raw
				echo - Comparison results: metadata_diff.txt, audio_diff.txt

				REM Note: Leaving temp files for inspection
				REM To clean up, uncomment the following line:
				REM rmdir /s /q "%temp_dir%"

				endlocal

				The script assumes ffmpeg is in your system PATH
				It uses 16-bit, 44100Hz, stereo as the PCM parameters
################

			# Using FFmpeg
			ffmpeg -i file.m4a -f ffmetadata metadata.txt

			# Using MediaInfo (more detailed)
			mediainfo file.m4a

			# Using AtomicParsley (specifically for MPEG-4 containers)
			AtomicParsley file.m4a -t

			# Using ExifTool (very comprehensive)
			exiftool file.m4a
#################

	How to identify if your file is lossless:

	Using FFmpeg:

	bash
	# For M4A files
	ffmpeg -i yourfile.m4a 2>&1 | findstr "Audio"
	# Look for "alac" in the output for lossless

	# For WMA files
	ffmpeg -i yourfile.wma 2>&1 | findstr "Audio"
	# Look for "wmapro" or "wmalossless" in the output
	Using MediaInfo:

	bash
	mediainfo yourfile.m4a
	# or
	mediainfo yourfile.wma


	Sample FFmpeg commands to create lossless versions:

	bash
	# Convert to M4A ALAC (lossless)
	ffmpeg -i input.wav -c:a alac output.m4a

	# Convert to WMA Lossless
	ffmpeg -i input.wav -c:a wmav2 -compression_level 100 output.wma


	To verify if your specific files are lossless:

	Check the bitrate - lossless will typically be > 500kbps for stereo
	Check the codec information
	Compare file sizes - lossless files will be much larger than lossy versions
####################


	For lossy format (maintaining similar quality):
	bash
	# Convert to AAC (M4A)
	ffmpeg -i "Black Is Black.wma" -c:a aac -b:a 192k "Black Is Black.m4a"

	# Or to MP3 (if wider compatibility needed)
	ffmpeg -i "Black Is Black.wma" -c:a libmp3lame -b:a 192k "Black Is Black.mp3"

	# Basic usage (convert to M4A)
	dotnet run -- --input "C:\Path\To\Music"

	# Convert to FLAC with high quality
	dotnet run -- --input "C:\Path\To\Music" --format flac --quality high

	# Convert to MP3 recursively
	dotnet run -- --input "C:\Path\To\Music" --format mp3 --recursive


	I've converted a wma file to m4a.  Are there any reasons to keep the wma version?
	Generally, there are very few reasons to keep the WMA version after converting to M4A, especially in 2025.

	Could I use ffmpeg to convert the lossy wma file to m4a?
	Yes, you can use FFmpeg to convert your lossy WMA file to M4A. Since your source WMA file uses the wmav2 codec at 192 kb/s, here's the optimal FFmpeg command:

	bash
	# Basic conversion with same quality
	ffmpeg -i "input.wma" -c:a aac -b:a 192k "output.m4a"

	# With metadata preservation and additional options
	ffmpeg -i "input.wma" -c:a aac -b:a 192k -map_metadata 0 -movflags +faststart "output.m4a"

	Let's break down the recommended command parameters:
		ffmpeg -i "input.wma"          # Input file
		-c:a aac                       # Use AAC codec (best for M4A)
		-b:a 192k                      # Match original bitrate
		-map_metadata 0               # Copy all metadata
		-movflags +faststart          # Optimize for streaming
		"output.m4a"                  # Output file


	Additional options you might want to consider:

	bash
	# Higher quality version (if desired)
	ffmpeg -i "input.wma" -c:a aac -b:a 256k -map_metadata 0 -movflags +faststart "output.m4a"

	# With specific AAC encoder (if available)
	ffmpeg -i "input.wma" -c:a libfdk_aac -b:a 192k -map_metadata 0 -movflags +faststart "output.m4a"

	# With quality-based VBR encoding
	ffmpeg -i "input.wma" -c:a aac -q:a 2 -map_metadata 0 -movflags +faststart "output.m4a"

	Remember:

	Since the source is lossy (WMA at 192 kb/s), there's no quality benefit in using higher bitrates
	AAC in M4A container is the most compatible modern format
	The -map_metadata 0 flag ensures all tags are preserved


	What is 'quality-based VBR encoding'?
	Quality-based VBR (Variable Bit Rate) encoding is an advanced audio encoding method that adjusts the bitrate dynamically based on the complexity of the audio signal. Let me break this down:

	VBR vs CBR (Constant Bit Rate):

	CBR: Uses the same bitrate throughout the file (e.g., constant 192 kbps)
	VBR: Varies the bitrate based on what the audio needs
	How Quality-based VBR works:

	Code
	Simple passage (e.g., silence)     → Lower bitrate (e.g., 32 kbps)
	Complex passage (e.g., orchestra)  → Higher bitrate (e.g., 320 kbps)
	FFmpeg's Quality Scale for AAC:

	Code
	-q:a VALUE    Where VALUE ranges from:
	0.1 = Highest quality (larger file)
	1   = Very good quality
	2   = Good quality (recommended)
	4   = Medium quality
	6   = Low quality (smaller file)
	Example FFmpeg commands showing different approaches:

	bash
	# CBR (Constant Bit Rate) - 192kbps always
	ffmpeg -i "input.wma" -c:a aac -b:a 192k "output.m4a"

	# VBR (Quality-based) - varies bitrate based on content
	ffmpeg -i "input.wma" -c:a aac -q:a 2 "output.m4a"

	# VBR with constraints (minimum and maximum bitrates)
	ffmpeg -i "input.wma" -c:a aac -q:a 2 -minrate 128k -maxrate 320k "output.m4a"


	Benefits of Quality-based VBR:

	Better Quality-to-Size Ratio:

	Uses more bits when needed
	Saves space on simple passages
	Overall more efficient
	Quality Consistency:

	Maintains consistent perceived quality
	Rather than consistent bitrate
	Better for variable content
	File Size Benefits:


	Use CBR when:
	- Streaming is primary use
	- Device compatibility is uncertain
	- Exact file size is important

	Use VBR when:
	- Quality is priority
	- Storage space is limited
	- Content has varying complexity

	For your WMA to M4A conversion, I'd recommend:

	bash
	# For best quality/size balance:
	ffmpeg -i "input.wma" -c:a aac -q:a 2 -map_metadata 0 -movflags +faststart "output.m4a"

	# For maximum compatibility:
	ffmpeg -i "input.wma" -c:a aac -b:a 192k -map_metadata 0 -movflags +faststart "output.m4a"

	will 'ffmpeg -i "input.wma" -c:a aac -q:a 2 -map_metadata 0 -movflags +faststart "output.m4a"' produce vbr output?
	Yes, the command ffmpeg -i "input.wma" -c:a aac -q:a 2 -map_metadata 0 -movflags +faststart "output.m4a" will produce VBR output, but there's an important caveat:

	The behavior depends on which AAC encoder FFmpeg is using. Let me break it down:

	Native FFmpeg AAC encoder (default):
	When you specify -c:a aac without explicitly choosing an encoder
	-q:a 2 will engage VBR mode
	Quality range is 0.1 (highest) to 6 (lowest)
	Will produce true VBR output
	To verify VBR encoding is working:
	bash
	# Before conversion, add -t 30 to test with just first 30 seconds
	ffmpeg -i "input.wma" -c:a aac -q:a 2 -map_metadata 0 -movflags +faststart -t 30 "test_output.m4a"

	# Then check the output file's properties
	ffprobe -i "test_output.m4a" -show_format | grep bit_rate

	# More explicit VBR command
	ffmpeg -i "input.wma" -c:a aac -q:a 2 -vbr on -map_metadata 0 -movflags +faststart "output.m4a"


	How can I check AAC encoder available?  Are there preferences?
	Let me help you check available AAC encoders and explain their differences.

	To check which AAC encoders are available in your FFmpeg installation:

	bash
	ffmpeg -encoders | grep aac


	AAC Encoder Preferences (from best to basic):

	libfdk_aac (Fraunhofer FDK AAC):

	Highest quality
	Best VBR implementation
	Not included in standard FFmpeg due to licensing
	bash
	# If available, use like this:
	ffmpeg -i input.wma -c:a libfdk_aac -vbr 3 output.m4a
	VBR quality scale: 1 (highest) to 5 (lowest)

	aac (Native FFmpeg AAC):

	Included by default
	Quality has improved significantly
	Decent VBR implementation
	bash
	ffmpeg -i input.wma -c:a aac -q:a 2 output.m4a
	VBR quality scale: 0.1 (highest) to 6 (lowest)


	# For libfdk_aac (if available):
	# High Quality VBR
	ffmpeg -i input.wma -c:a libfdk_aac -vbr 3 -map_metadata 0 -movflags +faststart output.m4a

	# For native FFmpeg AAC:
	# High Quality VBR
	ffmpeg -i input.wma -c:a aac -q:a 2 -vbr on -map_metadata 0 -movflags +faststart output.m4a



	# Convert MP3 to M4A (for better quality)
	ffmpeg -i input.mp3 -c:a aac -q:a 2 output.m4a



	To save a wma file to m4a, you gave this example: set FileName=%~n1 ffmpeg -i  %1 -c:a aac -b:a 192k %FileName%.m4a.  But the bitrate seems hard-coded.  How can direct ffmpeg to use the same bit rate of source?
	You can use FFmpeg's -b:a flag to set the bitrate for the audio encoding. However, FFmpeg does not have a direct option to automatically match the source bitrate. Instead, you can use a script to extract the source bitrate and then use it for the output file.

	Here's a Windows batch script that accomplishes this:


	For the AAC codec in FFmpeg, the -q:a option specifies the quality level for Variable Bit Rate (VBR) encoding. The quality scale typically ranges from 1 to 5, where:

	1 provides the highest quality and largest file size.
	5 provides the lowest quality and smallest file size.

Script
	@echo off
	REM Converts a FLAC file to ALAC using FFmpeg
	REM Usage: convert_flac_to_alac.bat input.flac output.m4a

	IF "%~1"=="" (
		echo Please provide the input FLAC file.
		echo Usage: %0 input.flac [output.m4a]
		exit /b 1
	)

	IF "%~2"=="" (
		set OUTPUT_FILE=%~n1.m4a
	) ELSE (
		set OUTPUT_FILE=%~2
	)

	:: ffmpeg          - The Program
	:: -i "%~1"        - Specifies the Input file
	:: -c:a alac       - Convert to ALAC Format
	:: -c:v copy       - Copy Video and Images Streams, as well
	:: -map_metadata 0 - Copy Metadata and Tags, as well
	::"%OUTPUT_FILE%"
	ffmpeg -i "%~1" -c:a alac -c:v copy -map_metadata 0 "%OUTPUT_FILE%"

	IF %ERRORLEVEL% EQU 0 (
		echo Conversion successful: %OUTPUT_FILE%
	) ELSE (
		echo Conversion failed.
	)

	convert_flac_to_alac.bat input.flac output.m4a
